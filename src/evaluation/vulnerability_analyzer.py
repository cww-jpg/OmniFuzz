import logging
from typing import Dict, List, Any
import json

class VulnerabilityAnalyzer:
    """Vulnerability analyzer"""

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.vulnerability_db = self._load_vulnerability_database()

    def _load_vulnerability_database(self) -> Dict[str, Any]:
        """Load vulnerability database"""
        # Simulated vulnerability database
        return {
            'buffer_overflow': {
                'cwe_id': 'CWE-119',
                'severity': 'high',
                'description': 'Buffer overflow',
                'common_locations': ['protocol parsing', 'packet processing'],
                'exploit_impact': 'Remote code execution'
            },
            'integer_overflow': {
                'cwe_id': 'CWE-190',
                'severity': 'medium',
                'description': 'Integer overflow',
                'common_locations': ['length calculation', 'index operations'],
                'exploit_impact': 'Denial of service or code execution'
            },
            'format_string': {
                'cwe_id': 'CWE-134',
                'severity': 'medium',
                'description': 'Format string vulnerability',
                'common_locations': ['logging', 'error handling'],
                'exploit_impact': 'Information disclosure or code execution'
            },
            'use_after_free': {
                'cwe_id': 'CWE-416',
                'severity': 'high',
                'description': 'Use after free',
                'common_locations': ['memory management', 'object lifecycle'],
                'exploit_impact': 'Code execution'
            },
            'double_free': {
                'cwe_id': 'CWE-415',
                'severity': 'high',
                'description': 'Double free',
                'common_locations': ['memory management'],
                'exploit_impact': 'Code execution'
            }
        }

    def analyze_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze a set of vulnerabilities"""
        analysis = {
            'total_vulnerabilities': len(vulnerabilities),
            'by_severity': {},
            'by_type': {},
            'by_protocol': {},
            'risk_assessment': {},
            'trends': {}
        }

        for vuln in vulnerabilities:
            # Count by severity
            severity = vuln.get('severity', 'unknown')
            analysis['by_severity'][severity] = analysis['by_severity'].get(severity, 0) + 1

            # Count by vulnerability type
            vuln_type = vuln.get('type', 'unknown')
            analysis['by_type'][vuln_type] = analysis['by_type'].get(vuln_type, 0) + 1

            # Count by protocol
            protocol = vuln.get('protocol', 'unknown')
            analysis['by_protocol'][protocol] = analysis['by_protocol'].get(protocol, 0) + 1

        # Risk assessment
        analysis['risk_assessment'] = self._assess_risk(analysis)

        return analysis

    def _assess_risk(self, analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Assess overall risk"""
        critical_count = analysis['by_severity'].get('critical', 0)
        major_count = analysis['by_severity'].get('major', 0)
        total_vulns = analysis['total_vulnerabilities']

        # Compute risk score
        risk_score = (critical_count * 10 + major_count * 5) / max(1, total_vulns)

        if risk_score >= 8:
            risk_level = 'critical'
        elif risk_score >= 5:
            risk_level = 'high'
        elif risk_score >= 3:
            risk_level = 'medium'
        else:
            risk_level = 'low'

        return {
            'risk_score': risk_score,
            'risk_level': risk_level,
            'critical_vulnerabilities': critical_count,
            'major_vulnerabilities': major_count,
            'recommendations': self._generate_recommendations(analysis)
        }

    def _generate_recommendations(self, analysis: Dict[str, Any]) -> List[str]:
        """Generate remediation recommendations"""
        recommendations = []

        # Type-based recommendations
        for vuln_type, count in analysis['by_type'].items():
            if vuln_type in self.vulnerability_db:
                db_info = self.vulnerability_db[vuln_type]
                recommendations.append(
                    f"Found {count} {db_info['description']} vulnerabilities ({vuln_type}); "
                    f"recommend reviewing code related to {', '.join(db_info['common_locations'])}"
                )

        # Severity-based recommendations
        critical_count = analysis['by_severity'].get('critical', 0)
        if critical_count > 0:
            recommendations.append(
                f"Found {critical_count} critical vulnerabilities; remediate immediately"
            )

        # Protocol-based recommendations
        for protocol, count in analysis['by_protocol'].items():
            if count > 5:  # many vulnerabilities for a protocol
                recommendations.append(
                    f"Protocol {protocol} has {count} vulnerabilities; increase testing and verification"
                )

        return recommendations

    def generate_vulnerability_report(self, vulnerabilities: List[Dict[str, Any]]) -> str:
        """Generate vulnerability report"""
        analysis = self.analyze_vulnerabilities(vulnerabilities)

        report = [
            "Vulnerability Analysis Report",
            "=" * 50,
            f"Total vulnerabilities: {analysis['total_vulnerabilities']}",
            "",
            "By severity:"
        ]

        for severity, count in analysis['by_severity'].items():
            report.append(f"  {severity}: {count}")

        report.append("\nBy vulnerability type:")
        for vuln_type, count in analysis['by_type'].items():
            description = self.vulnerability_db.get(vuln_type, {}).get('description', vuln_type)
            report.append(f"  {vuln_type} ({description}): {count}")

        report.append("\nBy protocol:")
        for protocol, count in analysis['by_protocol'].items():
            report.append(f"  {protocol}: {count}")

        report.append("\nRisk assessment:")
        risk = analysis['risk_assessment']
        report.append(f"  Risk score: {risk['risk_score']:.2f}")
        report.append(f"  Risk level: {risk['risk_level']}")
        report.append(f"  Critical vulnerabilities: {risk['critical_vulnerabilities']}")
        report.append(f"  Major vulnerabilities: {risk['major_vulnerabilities']}")

        report.append("\nRecommendations:")
        for i, recommendation in enumerate(risk['recommendations'], 1):
            report.append(f"  {i}. {recommendation}")

        return "\n".join(report)

    def export_to_json(self, vulnerabilities: List[Dict[str, Any]], filename: str):
        """Export vulnerability data to JSON file"""
        analysis = self.analyze_vulnerabilities(vulnerabilities)

        export_data = {
            'vulnerabilities': vulnerabilities,
            'analysis': analysis,
            'timestamp': '2024-01-01T00:00:00Z',  # should use actual timestamp
            'version': '1.0'
        }

        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, indent=2, ensure_ascii=False)
            self.logger.info(f"Vulnerability data exported to: {filename}")
        except Exception as e:
            self.logger.error(f"Error exporting vulnerability data: {e}")